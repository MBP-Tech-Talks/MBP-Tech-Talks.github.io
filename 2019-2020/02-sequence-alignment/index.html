---
title: DNA Sequencing
output:
    ioslides_presentation:
        incremental: true
        transition: faster
        css: ../style.css
author: James Hawley
date: 2019-10-18
autosize: true
---



<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script>
$(document).ready(function() {
  $('slide:not(.backdrop):not(.title-slide)').append('<div class=\"footnotes\">');

  $('footnote').each(function(index) {
    var text  = $(this).html();
    var fnNum = (index+1).toString();
    $(this).html(fnNum.sup());

    var footnote   = fnNum + '. ' + text + '<br/>';
    var oldContent = $(this).parents('slide').children('div.footnotes').html();
    var newContent = oldContent + footnote;
    $(this).parents('slide').children('div.footnotes').html(newContent);
  });
});
</script>

## MBP Tech Talks | Sequence Alignment

## Last session

* DNA sequencing technologies
* Phred quality scores
* FASTQ quality control
* Sequencing as a random sampling

## Outline

* Sequencing reads as strings
* Algorithms for finding string matches
* Algorithmic efficiency

## DNA sequencing

![High level overview of DNA sequencing]()

## DNA sequences as strings {.build}

```
@reference-seq-name1
ATCTATACTTTATCTTTATCTTTA
+
GFFFFBBBCBCCBBAAA:::;;;;
@reference-seq-name2
ATTTTATCGCGTAGCTAGCTGGCT
+
FFFEEBBBCBCCBBAAA:::;;;;
```

* Bunch of sequences and quality scores
* How do they relate to each other?

<div class="note">
* We have the sequences themselves
* As the title suggests, this general process is called "sequence alignment"
* Broad approach is going to be to line them up (match characters)
* To do this, we're going to have to build up the idea of what it means for 2 strings of letters to be similar
* First is the idea of a "string", how we're going to model the sequences
</div>

## Strings

* String: an ordered sequence of characters belonging to an alphabet
* $S_n = \left{ s_1, â€¦, s_n | s_i \in \Sigma \right},$ where $\Sigma}$ is the alphabet
* DNA: $\Sigma = {A, C, G, T}$
* RNA: $\Sigma = {A, C, G, U}$
* Protein: $\Sigma = {D, E, R, K, H, N, Q, S, T, Y, A, G, V, L, I, P, F, M, W, C}$

## String properties

* Length of a string: $|S_n| = n$
* Empty string: $\null$
* $|\null| = 0$

## String operations | Concatenation

* Two strings: S, T
* Concatenation(S, T) = ST
* Concatenation(T, S) = TS
* Note: ST != TS

## String operations | Indexing

* S[i] = (i + 1)th character of S
* Start counting i at 0

## String comparisons

* Substring: S is a substring of T if $\exists$ strings u, v, where T = uSv
* Prefix: S is a prefix of T if $\exists$ string v, where T = Sv
* Suffix: S is a suffix of T if $\exists$ string u, where T = uS

<div class="note">
* We've built up most of the machinery we need
</div>

## Exact string matching

* Take to strings S, T
* Assume |S| < |T|
* Find all positions (indices) in T where S matches exactly
